<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
</script>

<script type="module">
import * as THREE from 'three';
import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

const container = document.getElementById('canvas-container');

// ---------- BASIC RENDERER / CAMERA / SCENE ----------
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x000000, 0.0025);

const camera = new THREE.PerspectiveCamera(
  55,
  window.innerWidth / window.innerHeight,
  0.1,
  500
);
camera.position.set(0, 0.4, 7);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.2;
container.appendChild(renderer.domElement);

// ---------- POSTPROCESSING (BLOOM FOR GLOW) ----------
const composer = new EffectComposer(renderer);
const renderPass = new RenderPass(scene, camera);
composer.addPass(renderPass);

const bloomPass = new UnrealBloomPass(
  new THREE.Vector2(window.innerWidth, window.innerHeight),
  1.4, 0.4, 0.85
);
bloomPass.threshold = 0.0;
bloomPass.strength = 1.5;
bloomPass.radius = 0.6;
composer.addPass(bloomPass);

// ---------- LIGHTING ----------
const ambient = new THREE.AmbientLight(0x404040, 2.2);
scene.add(ambient);

const keyLight = new THREE.DirectionalLight(0xfff2cd, 2.5);
keyLight.position.set(5, 8, 10);
scene.add(keyLight);

const rimLight = new THREE.DirectionalLight(0x4da6ff, 1.5);
rimLight.position.set(-6, 3, -4);
scene.add(rimLight);

// ---------- OPTIONAL: HDRI FOR REALISTIC REFLECTIONS ----------
const pmrem = new THREE.PMREMGenerator(renderer);
pmrem.compileEquirectangularShader();

// TODO: replace with your own hosted HDR file or comment this block out if you don't have one
new RGBELoader()
  .setDataType(THREE.FloatType)
  .load('https://raw.githubusercontent.com/YourUser/YourRepo/main/space_4k.hdr', (hdrTex) => {
    const envMap = pmrem.fromEquirectangular(hdrTex).texture;
    scene.environment = envMap;
    scene.background = envMap; // comment this line if you prefer the black starfield only
    hdrTex.dispose();
    pmrem.dispose();
  });

// ---------- STARFIELD ----------
const starsGeom = new THREE.BufferGeometry();
const starCount = 4000;
const starPositions = new Float32Array(starCount * 3);
for (let i = 0; i < starCount * 3; i++) {
  starPositions[i] = (Math.random() - 0.5) * 300;
}
starsGeom.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
const starsMat = new THREE.PointsMaterial({
  size: 0.15,
  color: 0xffffff,
  transparent: true,
  opacity: 0.9,
  sizeAttenuation: true
});
const starsPoints = new THREE.Points(starsGeom, starsMat);
scene.add(starsPoints);

// ---------- ASTEROID FIELD (INSTANCED) ----------
const asteroidGeom = new THREE.DodecahedronGeometry(0.4, 0);
const asteroidMat = new THREE.MeshStandardMaterial({
  color: 0x777777,
  roughness: 0.95,
  metalness: 0.15,
  flatShading: true
});
const asteroidCount = 600;
const asteroids = new THREE.InstancedMesh(asteroidGeom, asteroidMat, asteroidCount);
const dummy = new THREE.Object3D();

for (let i = 0; i < asteroidCount; i++) {
  dummy.position.set(
    (Math.random() - 0.5) * 60,
    (Math.random() - 0.5) * 40,
    (Math.random() - 0.5) * 60
  );
  dummy.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
  const s = Math.random() * 0.7 + 0.1;
  dummy.scale.set(s, s, s);
  dummy.updateMatrix();
  asteroids.setMatrixAt(i, dummy.matrix);
}
scene.add(asteroids);

// ---------- LION ASTRONAUT AVATAR ----------
const lionGroup = new THREE.Group();
scene.add(lionGroup);

// Suit body
const bodyGeo = new THREE.BoxGeometry(1.5, 2.0, 1.0);
const bodyMat = new THREE.MeshPhysicalMaterial({
  color: 0xf2f2f2,
  roughness: 0.35,
  metalness: 0.4,
  clearcoat: 0.6,
  clearcoatRoughness: 0.3
});
const bodyMesh = new THREE.Mesh(bodyGeo, bodyMat);
bodyMesh.position.y = -0.6;
lionGroup.add(bodyMesh);

// Arms
const armGeo = new THREE.CapsuleGeometry(0.22, 0.8, 8, 16);
const armMat = bodyMat.clone();
const leftArm = new THREE.Mesh(armGeo, armMat);
const rightArm = new THREE.Mesh(armGeo, armMat);
leftArm.position.set(-1.0, -0.2, 0);
rightArm.position.set(1.0, -0.2, 0);
leftArm.rotation.z = 0.7;
rightArm.rotation.z = -0.7;
lionGroup.add(leftArm, rightArm);

// Helmet outer glass
const helmetOuterGeo = new THREE.SphereGeometry(1.1, 48, 48);
const helmetOuterMat = new THREE.MeshPhysicalMaterial({
  color: 0x6699ff,
  metalness: 0.9,
  roughness: 0.05,
  transparent: true,
  opacity: 0.25,
  transmission: 0.9,
  thickness: 0.4
});
const helmetOuter = new THREE.Mesh(helmetOuterGeo, helmetOuterMat);
helmetOuter.position.y = 1.0;
lionGroup.add(helmetOuter);

// Inner head sphere (gives volume behind the face texture)
const headGeo = new THREE.SphereGeometry(0.9, 32, 32);
const headMat = new THREE.MeshStandardMaterial({ color: 0xffb366, roughness: 0.6 });
const headMesh = new THREE.Mesh(headGeo, headMat);
headMesh.position.y = 1.0;
lionGroup.add(headMesh);

// Lion face plane (uses your lion PNG)
// TODO: change this URL to your actual lion face texture (square PNG, ideally transparent BG)
const lionFaceTextureUrl = 'https://raw.githubusercontent.com/YourUser/YourRepo/main/lion-face.png';

const texLoader = new THREE.TextureLoader();
texLoader.load(lionFaceTextureUrl, (lionTex) => {
  lionTex.encoding = THREE.sRGBEncoding;
  const faceGeo = new THREE.PlaneGeometry(1.4, 1.4);
  const faceMat = new THREE.MeshBasicMaterial({
    map: lionTex,
    transparent: true
  });
  const faceMesh = new THREE.Mesh(faceGeo, faceMat);
  faceMesh.position.set(0, 1.0, 0.82); // slightly in front of head, inside helmet
  lionGroup.add(faceMesh);
});

// MCF chest plate
const mcfPlateGeo = new THREE.PlaneGeometry(0.8, 0.45);
const mcfPlateMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
const mcfPlate = new THREE.Mesh(mcfPlateGeo, mcfPlateMat);
mcfPlate.position.set(0, -0.4, 0.51);
lionGroup.add(mcfPlate);

// Simple MCF text by using a texture generated from canvas
(function createMcfText() {
  const canvas = document.createElement('canvas');
  canvas.width = 256;
  canvas.height = 128;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = '#e53935';
  ctx.font = 'bold 72px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('MCF', canvas.width / 2, canvas.height / 2);

  const tex = new THREE.CanvasTexture(canvas);
  tex.encoding = THREE.sRGBEncoding;

  const geo = new THREE.PlaneGeometry(0.8, 0.4);
  const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.copy(mcfPlate.position);
  mesh.position.z += 0.01;
  lionGroup.add(mesh);
})();

// Jetpack cones (for flame)
const jetpackGeo = new THREE.CylinderGeometry(0.35, 0.5, 0.6, 16);
const jetpackMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.6, roughness: 0.3 });
const jetpack = new THREE.Mesh(jetpackGeo, jetpackMat);
jetpack.position.set(0, -1.7, -0.25);
jetpack.rotation.x = Math.PI / 2;
lionGroup.add(jetpack);

const flameGeo = new THREE.ConeGeometry(0.25, 1.4, 12);
const flameMat = new THREE.MeshBasicMaterial({ color: 0xff4411 });
const flameMesh = new THREE.Mesh(flameGeo, flameMat);
flameMesh.position.set(0, -2.3, -0.25);
lionGroup.add(flameMesh);

// Emissive point light to make flame bloom
const flameLight = new THREE.PointLight(0xff4400, 6, 20);
flameLight.position.copy(flameMesh.position);
scene.add(flameLight);

// Place avatar slightly in front of origin
lionGroup.position.set(0, 0, 0);

// ---------- CAMERA DRIFT & INTERACTION ----------
let targetCamX = 0;
let targetCamY = 0;

window.addEventListener('mousemove', (e) => {
  const xNorm = (e.clientX / window.innerWidth) * 2 - 1;
  const yNorm = (e.clientY / window.innerHeight) * 2 - 1;
  targetCamX = xNorm * 0.6;
  targetCamY = -yNorm * 0.4;
});

// ---------- ANIMATION LOOP ----------
const clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);
  const t = clock.getElapsedTime();

  // Subtle avatar bob + rotation
  lionGroup.position.y = Math.sin(t * 1.2) * 0.15;
  lionGroup.rotation.y = Math.sin(t * 0.5) * 0.25;

  // Flame flicker
  const flameScale = 0.8 + Math.sin(t * 30) * 0.2;
  flameMesh.scale.set(1, flameScale, 1);
  flameLight.intensity = 5 + Math.sin(t * 25) * 1.5;

  // Asteroid slow spin
  asteroids.rotation.y += 0.0008;
  asteroids.rotation.x += 0.0003;

  // Stars slow drift
  starsPoints.rotation.y += 0.0003;

  // Camera parallax
  camera.position.x += (targetCamX - camera.position.x) * 0.03;
  camera.position.y += (targetCamY - camera.position.y) * 0.03;
  camera.lookAt(0, 0, 0);

  composer.render();
}
animate();

// ---------- RESIZE ----------
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  composer.setSize(window.innerWidth, window.innerHeight);
});
</script>
